import { Inject, Injectable } from '@nestjs/common'
import { DefTransaction } from '@libs/@core/decorator'
import { RedisService } from '~/libs/@core/redis'
import { NSGlobal } from '~/libs/common/enums/NSGlobal'
import { MessagingProducerService } from '~/libs/@core/kafka'
import { NSMessage } from '~/libs/common/enums/NSMessage'

@Injectable()
export class ReportService {
	constructor(
		@Inject(MessagingProducerService)
		private readonly kafka: MessagingProducerService,
		@Inject(RedisService)
		private readonly cache: RedisService,
	) {}
	@DefTransaction()
	async getReport(id: string) {
		// check status of report
		const status = await this.cache.get(`report:${id}`)
		console.log('Report status:', status)
		if (!status) {
			return {
				id,
				status: NSGlobal.EventStatus.Failed,
				message: 'Report not found or has expired.',
			}
		}
		if (status !== NSGlobal.EventStatus.Success) {
			return {
				id,
				status: status,
				message: `Report is currently ${status}. Please wait until the report is completed.`,
			}
		}
		// Simulate fetching report data
		const reportData = {
			id,
			name: 'Demo Report',
			description: 'This is a demo report generated by the system.',
			status,
			progress: 100, // Assuming report is complete
			createdAt: new Date(),
			metadata: {
				userId: 'user-123',
				reportType: 'monthly',
				parameters: {
					startDate: '2023-01-01',
					endDate: '2023-01-31',
					filters: {
						status: 'active',
						category: 'sales',
					},
				},
			},
		}
		return {
			id,
			status,
			data: reportData,
			message: 'Report fetched successfully.',
		}
	}

	async startGenerateReport(reportId: string) {
		// Check if the report is already in progress
		const existingStatus = await this.cache.get(`report:${reportId}`)
		if (existingStatus) {
			return {
				id: reportId,
				status: NSGlobal.EventStatus.Processing,
				message: 'Report generation is already in progress.',
			}
		}
		const data = {
			id: reportId,
			name: 'Demo Long Process',
			description: 'This is a demo long process that simulates a long-running task.',
			status: 'in-progress',
			progress: 0,
			createdAt: new Date(),
			metadata: {
				userId: 'user-123',
				reportType: 'monthly',
				parameters: {
					startDate: '2023-01-01',
					endDate: '2023-01-31',
					filters: {
						status: 'active',
						category: 'sales',
					},
				},
			},
		}

		// const messagePayload: CreateActionLogMessagePayload = {
		//   userId,
		//   action: ActionLogTypeEnum.REGISTER,
		// };
		// const message = new CreateActionLogMessage([messagePayload]);

		const message: NSMessage.IMessageRecord = {
			topic: NSMessage.NSKafkaTopics.GENERATE_REPORT,
			messages: [
				{
					key: reportId,
					value: JSON.stringify(data),
					headers: 'reportId',
				},
			],
			messageType: '',
		}

		await this.kafka.produce(message)
		// set key to redis
		await this.cache.set(`report:${reportId}`, NSGlobal.EventStatus.Processing, 3600) // 1 hour expiration
		return {
			id: reportId,
			status: NSGlobal.EventStatus.Processing,
			message: 'Report generation started successfully.',
		}
	}

	async generateReportWithSimulatedTimeoutAndWait(reportId: string, timeout: number = 5000) {
		// Check if the report is already in progress
		const existingStatus = await this.cache.get(`report:${reportId}`)
		if (existingStatus) {
			return {
				id: reportId,
				status: NSGlobal.EventStatus.Processing,
				message: 'Report generation is already in progress.',
			}
		}

		// Simulate a long-running process with a timeout
		await this.simulateTimeout(reportId)

		// Set the report status to success after the simulated timeout
		await this.cache.set(`report:${reportId}`, NSGlobal.EventStatus.Success, 3600) // 1 hour expiration

		return {
			id: reportId,
			status: NSGlobal.EventStatus.Success,
			message: 'Report generated successfully after simulated timeout.',
		}
	}

	async simulateTimeout(id?: string): Promise<void> {
		// Simulate a timeout scenario
		const delay = Math.random() * 5000; // Random timeout between 0 and 5 seconds
		return new Promise<void>((resolve) => {
			setTimeout(() => {
				console.log('Simulated timeout occurred', id ? `for report ID: ${id}` : '')
				resolve()
			}, delay)
		})
	}
	async getReportStatus(reportId: string) {
		const status = await this.cache.get(`report:${reportId}`)
		if (!status) {
			return {
				id: reportId,
				status: NSGlobal.EventStatus.Failed,
				message: 'Report not found or has expired.',
			}
		}
		return {
			id: reportId,
			status,
			message: `Report is currently ${status}.`,
		}
	}
}
